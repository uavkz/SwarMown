{% extends "base.html" %}

{% load static %}

{% block head %}
    <link rel="stylesheet" href="{% static 'css/leaflet.css' %}"/>
    <script src="{% static 'js/leaflet.js' %}"></script>
    <script src="{% static 'js/pixi.min.js' %}"></script>
    <script src="{% static 'js/L.PixiOverlay.min.js' %}"></script>
    <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>
{% endblock %}

{% block title %}
    Управление маршрутом (Миссия {{ mission }})
{% endblock %}

{% block content %}
    <form action="" method="GET">
        <div class="row" style="margin-top: 10px;">
            <div class="col"></div>

            <div class="col">
                <label for="fieldName">Оптимизация движения машины</label>
                <select id="fieldName" name="carMove" class="form-control">
                    <option value="no" {% if request.GET.carMove == "no" %}selected{% endif %}>Без оптимизации и движения</option>
                    <option value="start_opt" {% if request.GET.carMove == "start_opt" %}selected{% endif %}>Оптимизация точки старта</option>
                    <option value="simple" {% if request.GET.carMove == "simple" %}selected{% endif %}>Равномерное движение</option>
                    <option value="genetic" {% if request.GET.carMove == "genetic" %}selected{% endif %}>Генетическая оптимизация</option>
                </select>
            </div>

            <div class="col">
                <label for="fieldName">Направление облета</label>
                <select id="fieldName" name="direction" class="form-control">
                    <option value="simple" {% if request.GET.direction == "simple" %}selected{% endif %}>Простая оптимизация</option>
                    <option value="horizontal" {% if request.GET.direction == "horizontal" %}selected{% endif %}>Горизонтальный</option>
                    <option value="vertical" {% if request.GET.direction == "vertical" %}selected{% endif %}>Вертикальный</option>
                    <option value="optimization" {% if request.GET.direction == "optimization" %}selected{% endif %}>EM оптимизация</option>
{#                    <option value="set" {% if request.GET.direction == "set" %}selected{% endif %}>Выбрать</option>#}
                </select>
            </div>

            <div class="col"></div>
        </div>

        <div class="row" style="margin-top: 10px;">
            <div class="col"></div>

            <div class="col">
                <label for="fieldName">Дополнительные функции</label>
                <div class="row">
                    <div class="col">
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" name="heightDiff" id="exampleCheck1" {% if '?' not in request.get_full_path or "heightDiff" in request.GET %}checked{% endif %}>
                            <label class="form-check-label" for="exampleCheck1" style="font-size: 0.75rem;">Развод по высотам</label>
                        </div>

                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" name="roundStartZone" id="exampleCheck2" {% if '?' not in request.get_full_path or "roundStartZone" in request.GET %}checked{% endif %}>
                            <label class="form-check-label" for="exampleCheck2" style="font-size: 0.75rem;">Облет зон старта по дуге</label>
                        </div>
                    </div>

                    <div class="col">
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" name="feature3" id="exampleCheck3" {% if "feature3" in request.GET %}checked{% endif %}>
                            <label class="form-check-label" for="exampleCheck3" style="font-size: 0.75rem;">Фича 3</label>
                        </div>

                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" name="feature4" id="exampleCheck4" {% if "feature4" in request.GET %}checked{% endif %}>
                            <label class="form-check-label" for="exampleCheck4" style="font-size: 0.75rem;">Фича 4</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col">
                <label for="fieldName">Точка старта</label>
                <select id="fieldName" name="start" class="form-control">
                    <option value="ne" {% if request.GET.start == "ne" %}selected{% endif %}>NE</option>
                    <option value="nw" {% if request.GET.start == "nw" %}selected{% endif %}>NW</option>
                    <option value="sw" {% if request.GET.start == "sw" %}selected{% endif %}>SW</option>
                    <option value="se" {% if request.GET.start == "se" %}selected{% endif %}>SE</option>
                </select>
            </div>

            <div class="col"></div>
        </div>

        <div class="row" style="margin-top: 10px;">
            <div class="col"></div>

            <div class="col">
                <label for="fieldName">Сериализованный объект</label>
                <input id="fieldName" name="serialized" class="form-control" value="{{ request.GET.serialized }}"/>
            </div>

            <div class="col"></div>
        </div>

        <div class="row">
            <div class="col"></div>

            <div class="col" style="text-align: right;">
                <button id="saveField" class="btn btn-primary" style="margin-top: 10px;" name="submitShow">Посмотреть маршрут</button>
            </div>

            <div class="col" style="text-align: left;">
                <button id="saveField" class="btn btn-primary" style="margin-top: 10px;" name="submitSave">Сохранить маршрут</button>
            </div>

            <div class="col"></div>
        </div>
        <div class="row" style="margin-top: 10px;">
            <div class="col"></div>

            <div class="col">
                <label for="height">Высота облёта над землёй (м)</label>
                <input autocomplete="off" id="height" name="height" class="form-control" value="{% if request.GET.height %}{{ request.GET.height }}{% else %}450{% endif %}"/>
            </div>
            <div class="col">
                <label for="height_absolute">Высота поля на уровнем моря (м)</label>
                <input autocomplete="off" id="height_absolute" name="height_absolute" class="form-control" value="{% if request.GET.height_absolute %}{{ request.GET.height_absolute }}{% else %}{% endif %}"/>
            </div>
            <div class="col" style="text-align: left; max-width: 170px; padding-top: 10px;">
                <button id="getCsv" class="btn btn-primary" style="margin-top: 0" name="getCsv">Скачать как CSV</button>
            </div>
            <div class="col" style="text-align: left; max-width: 220px; padding-top: 10px;">
                <button id="getJson" class="btn btn-primary" style="margin-top: 0" name="getJson">Скачать как Json (MavLink)</button>
            </div>

            <div class="col" style="text-align: left; max-width: 220px; padding-top: 10px;">
                <button id="exportRoutes" type="button" class="btn btn-secondary" style="margin-top:0">Экспорт PNG по маршрутам</button>
            </div>

            <div class="col"></div>
        </div>
    </form>

    <div id="map" style="height: 700px; margin-top: 10px;"></div>
{% endblock %}

{% block foot %}
    <script>
        function shuffle(array) {
            var currentIndex = array.length, temporaryValue, randomIndex;

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {

                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                // And swap it with the current element.
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }

            return array;
        }

        var colorPallete = [
            "#0072B2", "#D55E00", "#009E73", "#CC79A7",
            "#E69F00", "#56B4E9", "#F0E442", "#000000",
            "#FF4136", "#3D9970", "#7FDBFF", "#85144B",
            "#FF851B", "#1F77B4", "#2CA02C", "#9467BD"
        ];
        shuffle(colorPallete);
        for(let i = 0; i < 10; i++){
            colorPallete.concat(colorPallete);
        }

        var False = false;
        var True = true;
        var waypoints;
        var fieldPolygon;
        var holesPolygons;
        var gridStep;
        var initial;
        var map;
        var loader;
        var grid;
        var road;
        var tick;
        var project;
        var reverseProject;
        var stage;
        var mission_id = {{ mission.id }};
        var baseTiles;
        var routeLayers = [];
        var canvasRenderer;

        function getElevation(lat, lng) {
            const accessToken = 'pk.eyJ1Ijoia2luZHlhayIsImEiOiJja2F0cml2eTcwNDZhMnJvOXI4N2Y4MjRjIn0.f7FSJnib2jKKvtJe4ql-Bg';
            const url = `https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/${lng},${lat}.json?layers=contour&limit=50&access_token=${accessToken}`;

            return fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.features && data.features.length > 0) {
                        const elevations = data.features.map(feature => feature.properties.ele);
                        var highestElevation = Math.max(...elevations);
                        return highestElevation;
                    } else {
                        alert(`No elevation data available for (${lat}, ${lng}).`);
                    }
            }).catch(error => console.error('Error fetching elevation data:', error));
        }

        function initStuff() {
            fieldPolygon = {{ field|safe }};
            holesPolygons = {{ holes|safe }}; // Three-dimensional array [# First hole # [[lat, lon], [lat, lon], ...], # Second hole # [[lat, lon], [lat, lon], ...], ...]
            waypoints = {{ waypoints|safe }};
            {#waypoints = waypoints.slice(1); // TODO, remove first#}
            {#waypoints = waypoints.slice(0, -1); // TODO, remvoe last#}
            road = {{ road|safe }};
            
            for (i = 0; i < fieldPolygon.length; i++) {
                tmp = fieldPolygon[i][0];
                fieldPolygon[i][0] = fieldPolygon[i][1];
                fieldPolygon[i][1] = tmp;
            }
            fieldPolygon.push(fieldPolygon[0]);

            for (i = 0; i < holesPolygons.length; i++) {
                for (j = 0; j < holesPolygons[i].length; j++) {
                    tmp = holesPolygons[i][j][0];
                    holesPolygons[i][j][0] = holesPolygons[i][j][1];
                    holesPolygons[i][j][1] = tmp;
                }
                holesPolygons[i].push(holesPolygons[i][0]);
            }
            
            gridStep = {{ grid_step|safe }};

            // prepare circle texture, that will be our brush
            const brush = new PIXI.Graphics();
            brush.beginFill(0xffffff);
            brush.drawCircle(0, 0, 500);
            brush.endFill();

            initial = {{ initial|safe }};
            initial = [initial[1], initial[0]];
            canvasRenderer = L.canvas({ padding: 0.5 });
            map = L.map('map', { preferCanvas: true, renderer: canvasRenderer }).setView(initial, 13);
            baseTiles = L.tileLayer('https://api.mapbox.com/styles/v1/kindyak/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}', {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
                maxZoom: 18,
                id: 'ckzh2v0mz00dv14tafevvqzgs',
                tileSize: 512,
                zoomOffset: -1,
                accessToken: 'pk.eyJ1Ijoia2luZHlhayIsImEiOiJja2F0cml2eTcwNDZhMnJvOXI4N2Y4MjRjIn0.f7FSJnib2jKKvtJe4ql-Bg',
                crossOrigin: 'anonymous'
            }).addTo(map);

            map.on('click', function(e) {
                const { lat, lng } = e.latlng;
                getElevation(lat, lng)
                    .then(elevation => alert(`Elevation at (${lat}, ${lng}) is approximately ${elevation} meters.`))
                    .catch(error => alert(error.message));
            });

            {#getElevation(initial[0], initial[1])#}
            {#    .then(elevation => {#}
            {#        document.getElementById("height_absolute").value = elevation;#}
            {#    })#}
            {#    .catch(error => alert(error.message));#}

            grid = {{ grid|safe }};
            stage = new PIXI.Container();
            loader = new PIXI.Loader();
            loader.load(setupWrapper);
        }

        function setupWrapper(loader, resources) {
            var firstDraw = true;
            var prevZoom;

            var pixiOverlay = L.pixiOverlay(function (utils, event) {
                if(event.type !== 'redraw') {
                    var zoom = utils.getMap().getZoom();
                    var container = utils.getContainer();
                    var renderer = utils.getRenderer();
                    project = utils.latLngToLayerPoint;
                    reverseProject = utils.layerPointToLatLng;
                    var scale = utils.getScale();

                    setup(loader, resources, container, project, scale);

                    firstDraw = false;
                    prevZoom = zoom;
                    renderer.render(container);
                }
            }, stage);
            pixiOverlay.addTo(map);

            let ticker = new PIXI.Ticker();
            ticker.autoStart = false;
            ticker.stop()
            let renderer = PIXI.autoDetectRenderer();
            ticker.add(function (time) {
                {#gameLoop(time);#}
                pixiOverlay.redraw({type: "redraw", delta: time});
            });
            {#ticker.minFPS = 5;#}
            {#ticker.maxFPS = 60;#}
            ticker.start();
        }

        function setup(loader, resources, stage, project, scale) {
            let latLng = initial.slice();
            let coords = project(latLng);
            {#const background = new PIXI.Sprite(resources.badland.texture);#}
            {#stage.addChild(background);#}
            {#background.width = 1;#}
            {#background.height = 1;#}
            {#background.x = coords.x;#}
            {#background.y = coords.y;#}

            let field = new PIXI.Graphics();
            field.beginFill(0);

            // Draw grid TODO
            for (let point of grid) {
                let circle = L.circle([point[1], point[0]], {
                    color: '#da3e28',
                    fillOpacity: 0.5,
                    radius: 4
                }).addTo(map);
            }

            // Draw polygon
            var polyline = L.polyline(fieldPolygon, {color: 'red'}).addTo(map);
            // Draw holes
            for (let hole of holesPolygons) {
                var polyline = L.polyline(hole, {color: 'blue'}).addTo(map);
            }
            
            // Draw road
            for (let i = 0; i < road.length - 1; i++) {
                let cur = road[i].slice();
                const next = road[i + 1];
                while (Math.hypot(cur[0] - next[0], cur[1] - next[1]) > 0.0015) {
                    const dist = Math.hypot(next[0] - cur[0], next[1] - cur[1]);
                    cur[0] += (next[0] - cur[0]) / dist * 0.001;
                    cur[1] += (next[1] - cur[1]) / dist * 0.001;
                    L.circle([cur[1], cur[0]], {
                        color: '#FFDC00',
                        fillOpacity: 0,
                        weight: 3,
                        radius: 10
                    }).addTo(map);
                }
            }

            // Draw waypoints TODO
            routeLayers = [];
            for (let i = 0; i < waypoints.length; i++) {
                routeLayers.push(L.polyline(waypoints[i], {
                    color: colorPallete[i % colorPallete.length],
                    weight: 3,
                    smoothFactor: 1,
                    renderer: canvasRenderer,
                    interactive: false
                }).addTo(map));
            }

            return stage;
        }

        initStuff();

        function waitTiles(layer) {
            return new Promise(resolve => {
                if (layer._tiles && Object.values(layer._tiles).every(t => t.loaded)) resolve();
                else layer.once('load', resolve);
            });
        }

        function hideAllExcept(keep) {
            const hidden = [];
            map.eachLayer(l => {
                if (l === baseTiles) return;
                if (l === keep) return;
                hidden.push(l);
                map.removeLayer(l);
            });
            return hidden;
        }

        function restoreLayers(list) {
            for (const l of list) map.addLayer(l);
        }

        function savePng(filename) {
            const node = document.getElementById('map');
            return domtoimage.toBlob(node, {cacheBust: true, quality: 1, useCORS: true})
                .then(blob => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    a.click();
                    setTimeout(() => URL.revokeObjectURL(a.href), 1000);
                });
        }

        function saveCanvasAsPng(canvas, filename) {
            return new Promise((resolve) => {
                canvas.toBlob(function (blob) {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    a.click();
                    setTimeout(() => URL.revokeObjectURL(a.href), 1000);
                    resolve();
                });
            });
        }

        function leafletToCanvas(m) {
            return new Promise((resolve, reject) => {
                leafletImage(m, function (err, canvas) {
                    if (err) reject(err); else resolve(canvas);
                });
            });
        }

        function fitBoundsWithFixedPadding(m, bounds, padPx) {
            const size = m.getSize();
            const innerW = Math.max(1, size.x - 2 * padPx);
            const innerH = Math.max(1, size.y - 2 * padPx);
            const viewR = innerW / innerH;

            const crs = m.options.crs;
            const sw = crs.project(bounds.getSouthWest());
            const ne = crs.project(bounds.getNorthEast());

            let w = Math.abs(ne.x - sw.x);
            let h = Math.abs(ne.y - sw.y);
            if (w === 0 || h === 0) {
                m.fitBounds(bounds, {padding: [padPx, padPx], animate: false, maxZoom: 22});
                return;
            }

            let minX = Math.min(sw.x, ne.x), maxX = Math.max(sw.x, ne.x);
            let minY = Math.min(sw.y, ne.y), maxY = Math.max(sw.y, ne.y);

            const boxR = w / h;
            if (boxR > viewR) {
                const h2 = w / viewR, d = (h2 - h) / 2;
                minY -= d;
                maxY += d;
            } else {
                const w2 = h * viewR, d = (w2 - w) / 2;
                minX -= d;
                maxX += d;
            }

            const padded = L.latLngBounds(
                crs.unproject(L.point(minX, minY)),
                crs.unproject(L.point(maxX, maxY))
            );
            const z = m.getBoundsZoom(padded, false, [padPx, padPx]);
            m.setView(padded.getCenter(), z, {animate: false});
        }

        function boundsRatio(bounds, crs) {
            const sw = crs.project(bounds.getSouthWest());
            const ne = crs.project(bounds.getNorthEast());
            const w = Math.abs(ne.x - sw.x);
            const h = Math.abs(ne.y - sw.y);
            return (w > 0 && h > 0) ? (w / h) : 1;
        }

        function pickBoxSize(bounds, padPx, maxW, maxH, crs) {
            const r = boundsRatio(bounds, crs);
            const iwMax = Math.max(1, maxW - 2 * padPx);
            const ihMax = Math.max(1, maxH - 2 * padPx);
            let iw, ih;
            if (iwMax / ihMax >= r) {
                ih = ihMax;
                iw = ih * r;
            } else {
                iw = iwMax;
                ih = iw / r;
            }
            return {W: Math.round(iw + 2 * padPx), H: Math.round(ih + 2 * padPx)};
        }

        async function saveScaled(canvas, fname, targetW, targetH) {
            if (canvas.width === targetW && canvas.height === targetH) return saveCanvasAsPng(canvas, fname);
            const c2 = document.createElement('canvas');
            c2.width = targetW;
            c2.height = targetH;
            const ctx = c2.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(canvas, 0, 0, targetW, targetH);
            await saveCanvasAsPng(c2, fname);
        }

        async function exportRoutes() {
            const PAD_PX = 50;
            const DESIRED_SCALE = 3;
            const MAX_PIXELS = 28e6;

            const rect = document.getElementById('map').getBoundingClientRect();
            const maxW = Math.round(rect.width), maxH = Math.round(rect.height);

            const tileOpts = {
                id: baseTiles.options.id,
                tileSize: 512,
                zoomOffset: -1,
                maxZoom: 22,
                accessToken: baseTiles.options.accessToken,
                crossOrigin: 'anonymous'
            };

            const coreBounds = L.latLngBounds(fieldPolygon);
            const {W, H} = pickBoxSize(coreBounds, PAD_PX, maxW, maxH, map.options.crs);

            const capScale = Math.max(1, Math.floor(Math.sqrt(MAX_PIXELS / Math.max(1, W * H))));
            const S = Math.min(DESIRED_SCALE, capScale);

            // per-route exports with start/end markers
            for (let i = 0; i < waypoints.length; i++) {
                const box = document.createElement('div');
                box.style.position = 'fixed';
                box.style.left = '-10000px';
                box.style.top = '-10000px';
                box.style.width = (W * S) + 'px';
                box.style.height = (H * S) + 'px';
                document.body.appendChild(box);

                const renderer = L.canvas({padding: 0.5});
                const m = L.map(box, {
                    preferCanvas: true,
                    renderer,
                    zoomControl: false,
                    attributionControl: false,
                    fadeAnimation: false,
                    zoomAnimation: false,
                    markerZoomAnimation: false,
                    zoomSnap: 1,
                    zoomDelta: 1
                });

                try {
                    const tileUrl = 'https://api.mapbox.com/styles/v1/kindyak/{id}/tiles/512/{z}/{x}/{y}?access_token={accessToken}';
                    const tiles = L.tileLayer(tileUrl, tileOpts).addTo(m);

                    const field = L.polyline(fieldPolygon, {color: 'red', weight: 2 * S, renderer}).addTo(m);
                    for (const hole of (holesPolygons || [])) {
                        L.polyline(hole, {color: 'blue', weight: 2 * S, renderer}).addTo(m);
                    }

                    const route = L.polyline(waypoints[i], {
                        color: colorPallete[i % colorPallete.length],
                        weight: 3 * S,
                        renderer
                    }).addTo(m);

                    const pts = waypoints[i] || [];
                    if (pts.length > 0) {
                        L.circle(pts[0], {
                            color: '#00AA00',
                            fillColor: '#00AA00',
                            fillOpacity: 1,
                            weight: 0,
                            radius: 16 * S,
                            renderer
                        }).addTo(m);
                        L.circle(pts[pts.length - 1], {
                            color: '#FF0000',
                            fillColor: '#FF0000',
                            fillOpacity: 1,
                            weight: 0,
                            radius: 16 * S,
                            renderer
                        }).addTo(m);
                    }

                    const step = 0.001 / S;
                    const thr = step * 1.5;
                    for (let j = 0; j < road.length - 1; j++) {
                        let cur = road[j].slice();
                        const next = road[j + 1];
                        while (Math.hypot(cur[0] - next[0], cur[1] - next[1]) > thr) {
                            const dist = Math.hypot(next[0] - cur[0], next[1] - cur[1]);
                            cur[0] += (next[0] - cur[0]) / dist * step;
                            cur[1] += (next[1] - cur[1]) / dist * step;
                            L.circle([cur[1], cur[0]], {
                                color: '#FFDC00',
                                fillOpacity: 0,
                                weight: 3 * S,
                                radius: 10 * S,
                                renderer
                            }).addTo(m);
                        }
                    }

                    m.fitBounds(coreBounds, {padding: [PAD_PX, PAD_PX], animate: false, maxZoom: tileOpts.maxZoom});
                    m.setZoom(Math.floor(m.getZoom()), {animate: false});

                    await new Promise(res => tiles.once('load', res));
                    route.redraw();
                    field.redraw();
                    await new Promise(r => requestAnimationFrame(r));

                    const canvas = await leafletToCanvas(m);

                    const blob = await new Promise((res, rej) => {
                        try {
                            canvas.toBlob(b => b ? res(b) : rej(new Error('toBlob failed')), 'image/png');
                        } catch (e) {
                            rej(e);
                        }
                    }).catch(() => null);

                    if (blob) {
                        const a = document.createElement('a');
                        a.download = `${i + 1}.png`;
                        a.href = URL.createObjectURL(blob);
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => {
                            URL.revokeObjectURL(a.href);
                            a.remove();
                        }, 1000);
                    } else {
                        const a = document.createElement('a');
                        a.download = `${i + 1}.png`;
                        a.href = canvas.toDataURL('image/png');
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    }
                } catch (e) {
                    console.error('Export failed:', e);
                    alert('Экспорт маршрута не удался. Проверь консоль.');
                } finally {
                    m.remove();
                    box.remove();
                }
            }

            // single combined export without start/end markers
            {
                const box = document.createElement('div');
                box.style.position = 'fixed';
                box.style.left = '-10000px';
                box.style.top = '-10000px';
                box.style.width = (W * S) + 'px';
                box.style.height = (H * S) + 'px';
                document.body.appendChild(box);

                const renderer = L.canvas({padding: 0.5});
                const m = L.map(box, {
                    preferCanvas: true,
                    renderer,
                    zoomControl: false,
                    attributionControl: false,
                    fadeAnimation: false,
                    zoomAnimation: false,
                    markerZoomAnimation: false,
                    zoomSnap: 1,
                    zoomDelta: 1
                });

                try {
                    const tileUrl = 'https://api.mapbox.com/styles/v1/kindyak/{id}/tiles/512/{z}/{x}/{y}?access_token={accessToken}';
                    const tiles = L.tileLayer(tileUrl, tileOpts).addTo(m);

                    const field = L.polyline(fieldPolygon, {color: 'red', weight: 2 * S, renderer}).addTo(m);
                    for (const hole of (holesPolygons || [])) {
                        L.polyline(hole, {color: 'blue', weight: 2 * S, renderer}).addTo(m);
                    }

                    for (let i = 0; i < waypoints.length; i++) {
                        L.polyline(waypoints[i], {
                            color: colorPallete[i % colorPallete.length],
                            weight: 3 * S,
                            renderer
                        }).addTo(m);
                    }

                    const step = 0.001 / S;
                    const thr = step * 1.5;
                    for (let j = 0; j < road.length - 1; j++) {
                        let cur = road[j].slice();
                        const next = road[j + 1];
                        while (Math.hypot(cur[0] - next[0], cur[1] - next[1]) > thr) {
                            const dist = Math.hypot(next[0] - cur[0], next[1] - cur[1]);
                            cur[0] += (next[0] - cur[0]) / dist * step;
                            cur[1] += (next[1] - cur[1]) / dist * step;
                            L.circle([cur[1], cur[0]], {
                                color: '#FFDC00',
                                fillOpacity: 0,
                                weight: 3 * S,
                                radius: 10 * S,
                                renderer
                            }).addTo(m);
                        }
                    }

                    m.fitBounds(coreBounds, {padding: [PAD_PX, PAD_PX], animate: false, maxZoom: tileOpts.maxZoom});
                    m.setZoom(Math.floor(m.getZoom()), {animate: false});

                    await new Promise(res => tiles.once('load', res));
                    field.redraw();
                    await new Promise(r => requestAnimationFrame(r));

                    const canvas = await leafletToCanvas(m);
                    const blob = await new Promise((res, rej) => {
                        try {
                            canvas.toBlob(b => b ? res(b) : rej(new Error('toBlob failed')), 'image/png');
                        } catch (e) {
                            rej(e);
                        }
                    }).catch(() => null);

                    if (blob) {
                        const a = document.createElement('a');
                        a.download = `all.png`;
                        a.href = URL.createObjectURL(blob);
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => {
                            URL.revokeObjectURL(a.href);
                            a.remove();
                        }, 1000);
                    } else {
                        const a = document.createElement('a');
                        a.download = `all.png`;
                        a.href = canvas.toDataURL('image/png');
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    }
                } finally {
                    m.remove();
                    box.remove();
                }
            }
        }

        document.getElementById('exportRoutes').addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            await exportRoutes();
        });
    </script>
{% endblock %}
