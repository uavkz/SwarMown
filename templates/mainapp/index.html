{% extends "base.html" %}

{% load static %}

{% block head %}
    <link rel="stylesheet" href="{% static 'css/leaflet.css' %}"/>
    <script src="{% static 'js/leaflet.js' %}"></script>
    <script src="{% static 'js/pixi.min.js' %}"></script>
    <script src="{% static 'js/L.PixiOverlay.min.js' %}"></script>
{% endblock %}

{% block title %}
    Главная
{% endblock %}

{% block content %}
    <form action="" method="GET">
        <select name="algorithm">
            <option value="simple">Simple</option>
            <option value="ga">GA</option>
            <option value="zamboni">Zamboni</option>
        </select>

        <input type="number" name="grid_step" value="0.0025">
        <input type="submit" value="Запустить">
    </form>

    <div id="map" style="height: 700px;"></div>
{% endblock %}

{% block foot %}
    <script>
        function checkIfInPolygon(point, vs) {
            // ray-casting algorithm based on
            // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
            var x = point[0], y = point[1];

            var inside = false;
            for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                var xi = vs[i][0], yi = vs[i][1];
                var xj = vs[j][0], yj = vs[j][1];

                var intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect)
                    inside = !inside;
            }
            return inside;
        }

        var fieldPolygon = {{ field|safe }};
        for(i = 0; i < fieldPolygon.length; i++){
            tmp = fieldPolygon[i][0];
            fieldPolygon[i][0] = fieldPolygon[i][1];
            fieldPolygon[i][1] = tmp;
        }
        var gridStep = {{ grid_step|safe }};

        // prepare circle texture, that will be our brush
        const brush = new PIXI.Graphics();
        brush.beginFill(0xffffff);
        brush.drawCircle(0, 0, 500);
        brush.endFill();

        var initial = {{ initial|safe }};
        initial = [initial[1], initial[0]];
        var map = L.map('map').setView(initial, 13);
        L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}', {
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
            maxZoom: 18,
            id: 'mapbox/streets-v11',
            tileSize: 512,
            zoomOffset: -1,
            accessToken: 'pk.eyJ1Ijoia2luZHlhayIsImEiOiJja2F0cml2eTcwNDZhMnJvOXI4N2Y4MjRjIn0.f7FSJnib2jKKvtJe4ql-Bg'
        }).addTo(map);

        var loader = new PIXI.Loader();
        loader.add('crop_bad', '{% static 'img/textures/crop_bad.jpg' %}');
        loader.add('crop_good', '{% static 'img/textures/crop_good.jpg' %}');
        loader.add('badland', '{% static 'img/textures/badland.jpg' %}');
        loader.add('drone', '{% static 'img/textures/drone.png' %}');
        loader.add('pickup', '{% static 'img/textures/pickup.png' %}');
        loader.load(setupWrapper);
        var waypoints = {{ waypoints|safe }};
        var pickupWaypoints = {{ pickup_waypoints|safe }};
        var grid = {{ grid|safe }};
        var drones = [];
        var droneSpeed = 0.2;
        var pickupSpeed = 6;
        var tick = 0;
        var pickup;
        var project;
        let stage = new PIXI.Container();

        function setupWrapper(loader, resources) {
            var markerTexture = resources.drone.texture;
            var marker = new PIXI.Sprite(markerTexture);
            var firstDraw = true;
            var prevZoom;

            stage.addChild(marker);

            var pixiOverlay = L.pixiOverlay(function (utils) {
                var zoom = utils.getMap().getZoom();
                var container = utils.getContainer();
                var renderer = utils.getRenderer();
                project = utils.latLngToLayerPoint;
                var scale = utils.getScale();

                setup(loader, resources, container, project, scale);

                firstDraw = false;
                prevZoom = zoom;
                renderer.render(container);
            }, stage);
            pixiOverlay.addTo(map);

            let ticker = PIXI.Ticker.shared;
            ticker.autoStart = false;
            ticker.stop()
            let renderer = PIXI.autoDetectRenderer();
            ticker.add(function (time) {
                gameLoop(time);
                pixiOverlay.redraw();
            });
            ticker.minFPS = 5;
            ticker.maxFPS = 20;
            {#ticker.start();#}
        }

        function setup(loader, resources, stage, project, scale) {
            let latLng = initial.slice();
            let coords = project(latLng);
            {#const background = new PIXI.Sprite(resources.badland.texture);#}
            {#stage.addChild(background);#}
            {#background.width = 1;#}
            {#background.height = 1;#}
            {#background.x = coords.x;#}
            {#background.y = coords.y;#}

            let field = new PIXI.Graphics();
            field.beginFill(0);
            var fieldTiling = new PIXI.TilingSprite(resources.crop_bad.texture);
            fieldTiling.width = 10;
            fieldTiling.height = 10;
            fieldTiling.x = coords.x;
            fieldTiling.y = coords.y;
            stage.addChild(fieldTiling);
            let field_flat = {{ field_flat|safe }};
            for (let i = 0; i < field_flat.length; i++) {
                if (i % 2 === 1) {
                    continue;
                }
                let coords = project([field_flat[i], field_flat[i + 1]]);
                field_flat[i] = coords.x;
                field_flat[i + 1] = coords.y;
            }
            field.drawPolygon(field_flat);
            field.endFill();
            stage.addChild(field);
            fieldTiling.mask = field;

            for (i = 0; i < {{ number_of_drones }}; i++) {
                const drone = new PIXI.Sprite(resources.drone.texture);
                stage.addChild(drone);
                let coords = project([initial[0], initial[1]]);
                drone.x = coords.x;
                drone.y = coords.y;
                drone.width = 1/2;
                drone.height = 1/2;
                drones.push(drone);
            }

            pickup = new PIXI.Sprite(resources.pickup.texture);
            stage.addChild(pickup);
            coords = project([initial[0], initial[1]]);
            pickup.x = coords.x;
            pickup.y = coords.y;
            pickup.height = 1/2;
            pickup.width = 1;

            // Draw grid
            for (let point of grid) {
                let gridCircle = new PIXI.Graphics();
                gridCircle.beginFill(0xda3e28);
                stage.addChild(gridCircle);
                let coords = project([point[1], point[0]]);
                gridCircle.x = coords.x;
                gridCircle.y = coords.y;
                gridCircle.drawCircle(0, 0, gridStep*100);
                gridCircle.endFill();
            }

            return stage;
        }

        function gameLoop(delta) {
            tick += 1;
            if (tick % 600 === 0) {
                droneSpeed += 0.1;
            }
            let i = 0;
            // Moving Drones
            for (let drone of drones) {
                if (i >= waypoints.length || waypoints[i].length === 0) {
                    i++;
                    continue;
                }
                let my_waypoint = waypoints[i][0].slice();
                let coords = project([my_waypoint[1], my_waypoint[0]]);
                my_waypoint[0] = coords.x;
                my_waypoint[1] = coords.y;
                let delta_x = my_waypoint[0] - drone.width / 2 - drone.x;
                let delta_y = my_waypoint[1] - drone.height / 2 - drone.y;
                let delta = Math.sqrt(delta_x * delta_x + delta_y * delta_y);
                delta_x /= delta;
                delta_y /= delta;

                drone.x += delta_x * droneSpeed;
                drone.y += delta_y * droneSpeed;

                {#if(tick % Math.round((gridStep / droneSpeed / Math.max(10 / drones.length, 3))) === 0 &&#}
                {#    checkIfInPolygon([drone.x + drone.width / 2, drone.y + drone.height / 2], fieldPolygon)) {#}
                    let trail = new PIXI.Graphics();
                    trail.beginFill(0x00cc14);
                    stage.addChild(trail);
                    trail.x = drone.x + drone.width / 2;
                    trail.y = drone.y + drone.height / 2;
                    trail.drawCircle(0, 0, gridStep * 333);
                    trail.alpha = 0.2;
                    trail.endFill();
                {#}#}

                if (Math.abs(drone.x + drone.width / 2 - my_waypoint[0]) < droneSpeed / 2 &&
                    Math.abs(drone.y + drone.height / 2 - my_waypoint[1]) < droneSpeed / 2) {
                    waypoints[i].shift();
                    if (pickupWaypoints.length > 1 && i === 0) {
                        pickupWaypoints.shift();
                    }
                }
                i++;
            }

            // Moving pickup
            let my_waypoint = pickupWaypoints[0];
            if (!(Math.abs(pickup.x + pickup.width / 2 - my_waypoint[0]) < pickupSpeed &&
                Math.abs(pickup.y + pickup.height / 2 - my_waypoint[1]) < pickupSpeed)) {
                let delta_x = my_waypoint[0] - pickup.width / 2 - pickup.x;
                let delta_y = my_waypoint[1] - pickup.height / 2 - pickup.y;
                let delta_pickup = Math.sqrt(delta_x * delta_x + delta_y * delta_y);
                delta_x /= delta_pickup;
                delta_y /= delta_pickup;

                pickup.x += delta_x * pickupSpeed;
                pickup.y += delta_y * pickupSpeed;
            }
            i++;
        }
    </script>
{% endblock %}
