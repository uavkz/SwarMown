{% extends "base.html" %}

{% load static %}

{% block head %}
    <script src="{% static 'js/pixi.min.js' %}"></script>
{% endblock %}

{% block title %}
    Главная
{% endblock %}

{% block content %}

{% endblock %}

{% block foot %}
<script>
    function checkIfInPolygon(point, vs) {
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        var x = point[0], y = point[1];

        var inside = false;
        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            var xi = vs[i][0], yi = vs[i][1];
            var xj = vs[j][0], yj = vs[j][1];

            var intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }
        return inside;
    }

    var fieldPolygon = {{ field|safe }};
    var gridStep = {{ grid_step|safe }};

    const app = new PIXI.Application({width: 1200, height: 800});
    document.body.appendChild(app.view);
    const {stage} = app;

    // prepare circle texture, that will be our brush
    const brush = new PIXI.Graphics();
    brush.beginFill(0xffffff);
    brush.drawCircle(0, 0, 500);
    brush.endFill();

    app.loader.add('crop_bad', '{% static 'img/textures/crop_bad.jpg' %}');
    app.loader.add('crop_good', '{% static 'img/textures/crop_good.jpg' %}');
    app.loader.add('badland', '{% static 'img/textures/badland.jpg' %}');
    app.loader.add('drone', '{% static 'img/textures/drone.png' %}');
    app.loader.add('pickup', '{% static 'img/textures/pickup.png' %}');
    app.loader.load(setup);

    function setup(loader, resources) {
        const background = new PIXI.Sprite(resources.badland.texture);
        stage.addChild(background);
        background.width = app.screen.width;
        background.height = app.screen.height;

        let field = new PIXI.Graphics();
        field.beginFill(0);
        var fieldTiling = new PIXI.Sprite(resources.crop_bad.texture);
        fieldTiling.width = app.screen.width;
        fieldTiling.height = app.screen.height;
        stage.addChild(fieldTiling);
        field.drawPolygon({{ field_flat|safe }});
        field.endFill();
        stage.addChild(field);
        fieldTiling.mask = field;

        {#const renderTexture = PIXI.RenderTexture.create(1200, 800);#}
        {#const renderTextureSprite = new PIXI.TilingSprite(renderTexture);#}
        {#stage.addChild(renderTextureSprite);#}
        {#fieldReady.mask = renderTextureSprite;#}
        {#fieldReadyTiling.mask = fieldReady;#}

        var drones = [];
        var initial = {{ initial|safe }};
        for(i = 0; i < {{ number_of_drones }}; i++) {
            const drone = new PIXI.Sprite(resources.drone.texture);
            stage.addChild(drone);
            drone.x = initial[0];
            drone.y = initial[1];
            drone.width = 64;
            drone.height = 64;
            drones.push(drone);
        }

        const pickup = new PIXI.Sprite(resources.pickup.texture);
        stage.addChild(pickup);
        pickup.x = initial[0];
        pickup.y = initial[1];
        pickup.height = 70;
        pickup.width = 166;

        // Draw grid
        let grid = {{ grid|safe }};
        for(let point of grid){
            let gridCircle = new PIXI.Graphics();
            gridCircle.beginFill(0x00cc14);
            stage.addChild(gridCircle);
            gridCircle.x = point[0];
            gridCircle.y = point[1];
            gridCircle.drawCircle(0, 0, 10);
            gridCircle.endFill();
        }

        var waypoints = {{ waypoints|safe }}

        app.ticker.add(delta => gameLoop(delta));

        var droneSpeed = 10;
        var tick = 0;
        function gameLoop(delta) {
            tick += 1;
            if(tick % 600 === 0) {
                droneSpeed += 1;
                console.log(droneSpeed);
            }
            let i = 0;
            for(let drone of drones){
                if(waypoints[i].length === 0) {
                    i++;
                    continue;
                }
                let my_waypoint = waypoints[i][0];
                let delta_x = my_waypoint[0] - drone.height / 2 - drone.x;
                let delta_y = my_waypoint[1] - drone.height / 2 - drone.y;
                let delta = Math.sqrt(delta_x * delta_x + delta_y * delta_y);
                delta_x /= delta;
                delta_y /= delta;

                drone.x += delta_x * droneSpeed;
                drone.y += delta_y * droneSpeed;

                if(tick % (gridStep/droneSpeed/10) === 0 && checkIfInPolygon([drone.x + drone.width / 2, drone.y + drone.height / 2], fieldPolygon)){
                    let trail = new PIXI.Graphics();
                    trail.beginFill(0x00cc14);
                    stage.addChild(trail);
                    trail.x = drone.x + drone.width / 2;
                    trail.y = drone.y + drone.height / 2;
                    trail.drawCircle(0, 0, gridStep/1.9);
                    trail.alpha = 0.2;
                    trail.endFill();
                }

                if (Math.abs(drone.x + drone.width / 2 - my_waypoint[0]) < droneSpeed / 2 &&
                    Math.abs(drone.y + drone.height / 2 - my_waypoint[1]) < droneSpeed / 2) {
                    waypoints[i].shift();
                }
                i++;
            }
        }
    }
</script>
{% endblock %}
